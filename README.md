# git-tutorial
## 깃은 도대체 무엇인가?
위키백과에 깃(git)을 검색해보면 "컴퓨터 파일의 변경사항을 추적하고 여러 명의 사용자들 간의 해당 파일들의 작업을 조율하기 위한 **분산 버전 관리 시스템**" 라는 설명이 적혀있다. 대부분의 회사들은 자신들의 소스코드를 관리하기 위해 깃을 활용하기도 하고, 개발자 개인이 자신의 프로젝트를 진행하기 위해서도 깃을 적극 활용하고 있다.

### Commit
깃의 대표적인 기능들을 통해 이를 왜 활용하는지 알 수 있는데, 우선 첫번째로는 **commit**이 있다. 
```bash
git add ${파일들}
git commit -m "${업데이트 내역}"
```
위와 같은 명령어를 통해 개발 과정에서 수정된 소스코드를 추적할 수 있도록 해준다. 이렇게 되면 단계적으로 개발되어가는 과정을 커밋 메세지를 통해 이력을 남길 수 있고, 필요한 경우 원하는 시점으로 되돌아가서 새롭게 시작할 수도 있게 해준다.
깃을 활용하기 전에는 대부분 개인 컴퓨터 하드에 소스코드를 저장할 때에는 수정되는 시점에 따라 '\${날짜}\_\${프로젝트명}\_\${변경사항}'와 같은 길고 복잡한 이름을 통해 관리를 하게 된다. 이렇게 되면 프로젝트가 무거워짐에 따라 용량이 부담스러워 질 수도 있고, 어떤 변경사항이 어디에 기록되었는지 찾아보기도 매우 어려운 상태가 된다. 또한 변경점들 사이의 차이를 개발자가 한줄 한줄 읽어가며 찾아야 하기 때문에 문제가 되는 부분을 언제 수정했는지 찾는 것도 매우 어려워진다.
하지만 깃의 커밋 내역들을 제대로 관리 해왔다면 원하는 변경 사항을 상세한 커밋 메세지를 통해 확인 할 수도 있고, 그 당시 개발자가 어떤 수정을 진행하였는지 상세히 확인할 수 있어 아주 유용하다.

처음 깃을 사용하는 개발자들이 가장 많이 지키지 못하는 것이 있는데, 커밋을 자주 하지 않는 다는 것이다. 익숙하지 않다는 것을 핑계로 짧게는 하루, 길게는 며칠에 걸쳐 변경한 소스코드의 내용을 한꺼번에 커밋한다거나, 무의미한 커밋 메세지를 남기는 것이 가장 대표적이다. 커밋을 자주하지 않게 되면, 변경사항을 추적하는 것이 무색해지게 된다. 마찬가지로 커밋 메세지가 무의미한 것 역시 변경사항 추적을 하는 이유가 없어지게 된다. 가령 하루동안 무수히 많은 함수의 내용을 수정하였고, 커밋 메세지를 `fix`라고만 작성해 놓았다면 깃을 사용하지 않았을 때와 거의 비슷한 수준으로 내가 찾고자 하는 부분을 찾기 매우 어려워 진다. 별 것 아니고 귀찮다는 이유로 넘기지 않고 커밋은 유의미한 변경 사항이 있게 되면 그때 적절한 메세지로 남겨 놓는 것이 좋다.

### Branch
다음으로는 **branch**이다.
```bash
git branch feature/${개발피처}
git checkout feature/${개발피처}
```
위 명령어는 새로운 브랜치를 생성하고, 해당 브랜치로 체크아웃 하는 것을 의미한다. 기본적으로 브랜치라는 것은 협업 과정에서 자연스럽게 필요해지는 것이다. 가령 깃에서 기본으로 제공하는 `master`브랜치나 `main`브랜치만 사용하는 경우, 여러 사람이 작업을 하게 되면 커밋 내역이 뒤섞이게 되면서 작업 내역을 한눈에 알아보기 어렵다. 심지어 동일한 파일을 수정하고 있는 경우에는 새로운 변경점을 제때 당겨(`pull`, 원격 저장소의 내용을 받아 오는 행위)오지 않으면 내 변경 내역을 밀어(`push`, 로컬 저장소의 내용을 원격 저장소로 밀어 넣는 행위)넣을 때 수 많은 에러를 마주할 수 도 있다. 이러한 부분을 해결하기 위해선 개발자들은 자신이 개발하고자 하는 내용의 `feature`브랜치를 생성하여 안전하게 작업하고, 최종본을 `main`브랜치로 병합할 때 충돌 지점만 정리하면 되기 때문에 자주 사용하게 된다.

### 리뷰 프로세스
마지막으론 직접적인 명령어는 아니지만, `Gitlab`이나 `Github`에서 제공하는 리뷰 프로세스이다. Gitlab에서는 `Merge Request`(MR)이라 부르고, github에서는 `Pull Request`(PR)이라 부른다. 이것은 해당 저장소의 관리자에게 개발자가 수정한 내용을 병합해달라는 요청을 보내는 것이다. 이 과정을 통해서 개발자는 자신이 수정한 내용을 최초로 관리자에게 보여주어야 하게 된다. 이 때 관리자는 개발자가 요청한 변경사항들에 대해 아래 몇가지 사항들에 대해 검토를 한 후, 승인을 결정한다.
1. 저장소에 명시한 기여 방법을 제대로 지켰는지 확인하고, 
2. 코딩 스타일을 준수하였는지 확인하고, 
3. 제안된 변경 사항이 유의미 한지 확인한다.

이러한 과정을 통해 개발자는 자신이 몰랐던 부분들을 다시 한번 확인할 수 있고, 소스코드는 보다 안정적으로 유지보수될 수 있다.

리뷰 프로세스 역시 익숙하지 않은 개발자들과 관리자가 실수 하는 부분이 있는데, 먼저 개발자 관점에서는 불친절한 요청이 대표적이다. 한번의 요청에 너무 많은 변경사항들이 있다면 리뷰어가 해당 내용을 검토하기 매우 어려워져 소스코드의 안정성을 위해 거절할 수 밖에 없게 된다. 또한 변경점이 적당하더라도 내가 의도한 부분에 대해 적절한 리뷰를 받고자 한다면 리뷰어 입장에서 요청 사항을 작성해보는 것이 좋다.
관리자가 실수하기 가장 좋은 부분은 완벽한 소스코드를 바란다는 점이다. 대체로 `완벽`하다는 것은 주관이 강하게 반영되어 있을 가능성이 크다. 개발자 입장에선 완벽해보이는 부분에 관리자가 사소한 부분에 딴지를 건다고 생각할 수도 있다. 따라서 관리자가 리뷰할 때에는 반드시 "LGTM(Look Good To Me, 내가 보기엔 괜찮네요)" 정도가 된다면 승인을 고려하는 것이 좋다.

## 깃헙에서 저장소 생성하기
![image](/assets/create-repository.PNG)\
![image](/assets/create-repository1.PNG)\
![image](/assets/create-repository2.PNG)

## Git 로컬에 설치하기
![image](/assets/install-git-bash.PNG)\
![image](/assets/install-git-bash1.PNG)\
![image](/assets/install-git-bash2.PNG)\
![image](/assets/install-git-bash3.PNG)\
![image](/assets/install-git-bash4.PNG)\
![image](/assets/install-git-bash5.PNG)

## 로컬 저장소에 저장하기
![image](/assets/clone-repository.PNG)\
![image](/assets/clone-repository1.PNG)\
![image](/assets/clone-repository2.PNG)\
![image](/assets/clone-repository3.PNG)\
![image](/assets/clone-repository4.PNG)

## 변경 사항 원격 저장소에 푸쉬하기
![image](/assets/push-repository.PNG)\
![image](/assets/push-repository1.PNG)\
![image](/assets/push-repository2.PNG)\
![image](/assets/push-repository3.PNG)\
![image](/assets/push-repository4.PNG)\
![image](/assets/push-repository5.PNG)

